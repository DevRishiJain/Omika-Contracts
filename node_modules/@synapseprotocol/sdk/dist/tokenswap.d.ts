import type { Token } from "./token";
import { SwapContract } from "./contracts";
import { BigNumber, type BigNumberish } from "@ethersproject/bignumber";
import type { PopulatedTransaction } from "@ethersproject/contracts";
export declare namespace UnsupportedSwapErrors {
    enum UnsupportedSwapErrorKind {
        UnsupportedToken = 0,
        UnsupportedTokenNetFrom = 1,
        UnsupportedTokenNetTo = 2,
        NonmatchingSwapTypes = 3
    }
    interface UnsupportedSwapError {
        errorKind: UnsupportedSwapErrorKind;
        reason: string;
    }
    const tokenNotSupported: (t: {
        symbol: string;
    }, netName: string) => UnsupportedSwapError;
    const tokenNotSupportedNetFrom: (t: {
        symbol: string;
    }, netName: string) => UnsupportedSwapError;
    const tokenNotSupportedNetTo: (t: {
        symbol: string;
    }, netName: string) => UnsupportedSwapError;
    const nonMatchingSwapTypes: () => UnsupportedSwapError;
}
export declare namespace TokenSwap {
    export interface SwapParams {
        chainId: number;
        tokenFrom: Token;
        tokenTo: Token;
        amountIn: BigNumberish;
        swapData?: SwapSetup;
    }
    export interface SwapTokensParams extends SwapParams {
        minAmountOut: BigNumberish;
        deadline?: number;
    }
    export interface BridgeSwapSupportedParams {
        tokenFrom: Token;
        tokenTo: Token;
        chainIdFrom: number;
        chainIdTo: number;
    }
    export type EstimatedSwapRate = {
        amountOut: BigNumber;
    };
    export type IntermediateSwapTokens = {
        intermediateToken?: Token;
        bridgeConfigIntermediateToken: Token;
    };
    export type SwapSupportedResult = {
        swapSupported: boolean;
        reasonNotSupported?: UnsupportedSwapErrors.UnsupportedSwapError;
    };
    export type DetailedTokenSwapMap = {
        [chainId: number]: {
            token: Token;
            [chainId: number]: Token[];
        }[];
    };
    export function swapSupported(args: SwapParams): SwapSupportedResult;
    export function bridgeSwapSupported(args: BridgeSwapSupportedParams): SwapSupportedResult;
    export function calculateSwapRate(args: SwapParams): Promise<EstimatedSwapRate>;
    export function buildSwapTokensTransaction(args: SwapTokensParams): Promise<PopulatedTransaction>;
    export function intermediateTokens(chainId: number, token: Token): IntermediateSwapTokens;
    export function detailedTokenSwapMap(): DetailedTokenSwapMap;
    interface SwapSetup {
        swapInstance: SwapContract;
        tokenIndexFrom: number;
        tokenIndexTo: number;
    }
    export function swapSetup(tokenFrom: Token, tokenTo: Token, chainId: number): Promise<SwapSetup>;
    export {};
}
