import { ChainId } from "./chainid.js";
import { Tokens } from "../tokens.js";
import { SwapPools } from "../swappools.js";
import { BridgeUtils } from "../bridge/bridgeutils.js";
export var Networks;
(function (Networks) {
    const tokenSupportChecks = [
        { chainId: ChainId.ETH, token: Tokens.WETH },
        { chainId: ChainId.ETH, token: Tokens.NETH },
        { chainId: ChainId.AVALANCHE, token: Tokens.AVAX },
        { chainId: ChainId.AVALANCHE, token: Tokens.WAVAX },
        { chainId: ChainId.AVALANCHE, token: Tokens.AVWETH },
        { chainId: ChainId.MOONRIVER, token: Tokens.MOVR },
        { chainId: ChainId.MOONRIVER, token: Tokens.WMOVR },
    ];
    const checkWrappedToken = (chainId, token) => {
        let check = tokenSupportChecks.find((check) => check.chainId === chainId && check.token.isEqual(token));
        return typeof check !== "undefined";
    };
    class Network {
        id;
        name;
        chainCurrency;
        chainId;
        tokens;
        tokenAddresses;
        constructor(args) {
            this.name = args.name;
            this.chainId = args.chainId;
            this.chainCurrency = args.chainCurrency;
            this.tokens = SwapPools.getAllSwappableTokensForNetwork(this.chainId);
            this.tokenAddresses = this.tokens.map((t) => t.address(this.chainId));
            this.id = Symbol(`${this.name}:${this.chainId}`);
        }
        /**
         * Returns true if the Bridge Zap contract for this network
         * is a L2BridgeZap contract.
         * Currently, Ethereum mainnet is the only network for which the
         * Bridge Zap contract is a NerveBridgeZap contract.
         */
        get zapIsL2BridgeZap() {
            return this.chainId !== ChainId.ETH;
        }
        /**
         * Returns true if the passed token is available on this network.
         * @param {Token} token A {@link Token} object.
         */
        supportsToken(token) {
            let checkSymbol = token.symbol;
            const isEthish = checkSymbol === "ETH" && (this.chainId === ChainId.ETH || BridgeUtils.isL2ETHChain(this.chainId)), isWrapped = checkWrappedToken(this.chainId, token);
            if (isEthish || isWrapped) {
                return true;
            }
            let tokenAddr = token.address(this.chainId);
            return tokenAddr !== null
                ? this.tokenAddresses.includes(tokenAddr)
                : false;
        }
    }
    Networks.Network = Network;
    Networks.ETH = new Network({
        name: "Ethereum Mainnet",
        chainId: ChainId.ETH,
        chainCurrency: "ETH"
    });
    Networks.OPTIMISM = new Network({
        name: "Optimism",
        chainId: ChainId.OPTIMISM,
        chainCurrency: "ETH"
    });
    Networks.CRONOS = new Network({
        name: "Cronos",
        chainId: ChainId.CRONOS,
        chainCurrency: "CRO"
    });
    Networks.BSC = new Network({
        name: "Binance Smart Chain",
        chainId: ChainId.BSC,
        chainCurrency: "BNB",
    });
    Networks.POLYGON = new Network({
        name: "Polygon",
        chainId: ChainId.POLYGON,
        chainCurrency: "MATIC",
    });
    Networks.FANTOM = new Network({
        name: "Fantom",
        chainId: ChainId.FANTOM,
        chainCurrency: "FTM",
    });
    Networks.BOBA = new Network({
        name: "Boba Network",
        chainId: ChainId.BOBA,
        chainCurrency: "ETH",
    });
    Networks.METIS = new Network({
        name: "Metis",
        chainId: ChainId.METIS,
        chainCurrency: "Metis",
    });
    Networks.MOONBEAM = new Network({
        name: "Moonbeam",
        chainId: ChainId.MOONBEAM,
        chainCurrency: "GLMR",
    });
    Networks.MOONRIVER = new Network({
        name: "Moonriver",
        chainId: ChainId.MOONRIVER,
        chainCurrency: "MOVR",
    });
    Networks.ARBITRUM = new Network({
        name: "Arbitrum",
        chainId: ChainId.ARBITRUM,
        chainCurrency: "ETH",
    });
    Networks.AVALANCHE = new Network({
        name: "Avalanche C-Chain",
        chainId: ChainId.AVALANCHE,
        chainCurrency: "AVAX",
    });
    Networks.AURORA = new Network({
        name: "Aurora",
        chainId: ChainId.AURORA,
        chainCurrency: "aETH",
    });
    Networks.HARMONY = new Network({
        name: "Harmony",
        chainId: ChainId.HARMONY,
        chainCurrency: "ONE",
    });
    const CHAINID_NETWORK_MAP = {
        [ChainId.ETH]: Networks.ETH,
        [ChainId.OPTIMISM]: Networks.OPTIMISM,
        [ChainId.CRONOS]: Networks.CRONOS,
        [ChainId.BSC]: Networks.BSC,
        [ChainId.POLYGON]: Networks.POLYGON,
        [ChainId.FANTOM]: Networks.FANTOM,
        [ChainId.BOBA]: Networks.BOBA,
        [ChainId.METIS]: Networks.METIS,
        [ChainId.MOONBEAM]: Networks.MOONBEAM,
        [ChainId.MOONRIVER]: Networks.MOONRIVER,
        [ChainId.ARBITRUM]: Networks.ARBITRUM,
        [ChainId.AVALANCHE]: Networks.AVALANCHE,
        [ChainId.AURORA]: Networks.AURORA,
        [ChainId.HARMONY]: Networks.HARMONY,
    };
    Networks.networkName = (chainId) => Networks.fromChainId(chainId).name;
    Networks.fromChainId = (chainId) => CHAINID_NETWORK_MAP[chainId] ?? null;
    /**
     * Returns true if the passed network supports the passed token.
     * @param {Network | number} network Either a {@link Network} instance, or the Chain ID of a supported network.
     * @param {Token} token A {@link Token} object.
     */
    Networks.networkSupportsToken = (network, token) => (network instanceof Network
        ? network
        : Networks.fromChainId(network)).supportsToken(token);
    Networks.supportedNetworks = () => Object.values(CHAINID_NETWORK_MAP);
})(Networks || (Networks = {}));
export const supportedNetworks = Networks.supportedNetworks;
