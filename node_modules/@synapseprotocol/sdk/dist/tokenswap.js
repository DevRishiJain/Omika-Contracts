import { ChainId, supportedChainIds } from "./common/chainid.js";
import { Networks } from "./common/networks.js";
import { Tokens } from "./tokens.js";
import { SwapPools } from "./swappools.js";
import { rejectPromise } from "./common/utils.js";
import { BridgeConfigV3ContractInstance } from "./entities.js";
import { SwapFactory } from "./contracts.js";
import { SwapType, mintBurnSwapTypes, rpcProviderForChain } from "./internal/index.js";
export var UnsupportedSwapErrors;
(function (UnsupportedSwapErrors) {
    let UnsupportedSwapErrorKind;
    (function (UnsupportedSwapErrorKind) {
        UnsupportedSwapErrorKind[UnsupportedSwapErrorKind["UnsupportedToken"] = 0] = "UnsupportedToken";
        UnsupportedSwapErrorKind[UnsupportedSwapErrorKind["UnsupportedTokenNetFrom"] = 1] = "UnsupportedTokenNetFrom";
        UnsupportedSwapErrorKind[UnsupportedSwapErrorKind["UnsupportedTokenNetTo"] = 2] = "UnsupportedTokenNetTo";
        UnsupportedSwapErrorKind[UnsupportedSwapErrorKind["NonmatchingSwapTypes"] = 3] = "NonmatchingSwapTypes";
    })(UnsupportedSwapErrorKind = UnsupportedSwapErrors.UnsupportedSwapErrorKind || (UnsupportedSwapErrors.UnsupportedSwapErrorKind = {}));
    UnsupportedSwapErrors.tokenNotSupported = (t, netName) => ({
        errorKind: UnsupportedSwapErrorKind.UnsupportedToken,
        reason: `Token ${t.symbol} not supported on network ${netName}`,
    });
    UnsupportedSwapErrors.tokenNotSupportedNetFrom = (t, netName) => ({
        errorKind: UnsupportedSwapErrorKind.UnsupportedTokenNetFrom,
        reason: `Token ${t.symbol} not supported on 'from' network ${netName}`,
    });
    UnsupportedSwapErrors.tokenNotSupportedNetTo = (t, netName) => ({
        errorKind: UnsupportedSwapErrorKind.UnsupportedTokenNetTo,
        reason: `Token ${t.symbol} not supported on 'to' network ${netName}`,
    });
    UnsupportedSwapErrors.nonMatchingSwapTypes = () => ({
        errorKind: UnsupportedSwapErrorKind.NonmatchingSwapTypes,
        reason: "Token swap types don't match",
    });
})(UnsupportedSwapErrors || (UnsupportedSwapErrors = {}));
export var TokenSwap;
(function (TokenSwap) {
    const BRIDGE_CONFIG_INSTANCE = BridgeConfigV3ContractInstance();
    function swapSupported(args) {
        const { tokenFrom, tokenTo, chainId } = args;
        return checkCanSwap(tokenFrom, tokenTo, chainId);
    }
    TokenSwap.swapSupported = swapSupported;
    function bridgeSwapSupported(args) {
        const { tokenFrom, tokenTo, chainIdFrom, chainIdTo } = args;
        return checkCanSwap(tokenFrom, tokenTo, chainIdFrom, chainIdTo);
    }
    TokenSwap.bridgeSwapSupported = bridgeSwapSupported;
    async function calculateSwapRate(args) {
        const { swapSupported: canSwap, reasonNotSupported } = swapSupported(args);
        if (!canSwap) {
            return rejectPromise(reasonNotSupported);
        }
        return resolveSwapData(args)
            .then(({ swapInstance, tokenIndexFrom, tokenIndexTo }) => swapInstance.calculateSwap(tokenIndexFrom, tokenIndexTo, args.amountIn)
            .then((res) => ({ amountOut: res })))
            .catch(rejectPromise);
    }
    TokenSwap.calculateSwapRate = calculateSwapRate;
    async function buildSwapTokensTransaction(args) {
        const { swapSupported: canSwap, reasonNotSupported } = swapSupported(args);
        if (!canSwap) {
            return rejectPromise(reasonNotSupported);
        }
        return resolveSwapData(args)
            .then(populateSwapTransaction(args))
            .catch(rejectPromise);
    }
    TokenSwap.buildSwapTokensTransaction = buildSwapTokensTransaction;
    async function resolveSwapData(args) {
        const { swapData } = args;
        return Promise.resolve(swapData ? swapData : await swapSetup(args.tokenFrom, args.tokenTo, args.chainId));
    }
    function populateSwapTransaction(args) {
        return (swapSetup) => {
            let { deadline } = args;
            const { swapInstance, tokenIndexFrom, tokenIndexTo } = swapSetup;
            deadline = deadline ?? Math.round((new Date().getTime() / 1000) + 60 * 10);
            const overrides = args.tokenFrom.isEqual(Tokens.ETH) ? { value: args.amountIn } : {};
            return swapInstance.populateTransaction.swap(tokenIndexFrom, tokenIndexTo, args.amountIn, args.minAmountOut, deadline, overrides);
        };
    }
    function intermediateTokens(chainId, token) {
        if (mintBurnSwapTypes.includes(token.swapType)) {
            return { intermediateToken: token, bridgeConfigIntermediateToken: token };
        }
        let intermediateToken, bridgeConfigIntermediateToken;
        switch (token.swapType) {
            case SwapType.SYN:
                intermediateToken = Tokens.SYN;
                break;
            case SwapType.FRAX:
                bridgeConfigIntermediateToken = chainId === ChainId.ETH ? Tokens.FRAX : Tokens.SYN_FRAX;
                break;
            case SwapType.ETH:
                intermediateToken = Tokens.NETH;
                bridgeConfigIntermediateToken = chainId === ChainId.ETH ? Tokens.WETH : Tokens.NETH;
                break;
            case SwapType.AVAX:
                intermediateToken = Tokens.WAVAX;
                break;
            case SwapType.MOVR:
                intermediateToken = Tokens.WMOVR;
                break;
            default:
                intermediateToken = Tokens.NUSD;
                break;
        }
        bridgeConfigIntermediateToken = bridgeConfigIntermediateToken ?? intermediateToken;
        return { intermediateToken, bridgeConfigIntermediateToken };
    }
    TokenSwap.intermediateTokens = intermediateTokens;
    function detailedTokenSwapMap() {
        let res = {};
        const allChainIds = supportedChainIds();
        for (const c1 of allChainIds) {
            let n1 = Networks.fromChainId(c1);
            let networkTokens = n1.tokens;
            res[c1] = networkTokens.map((t) => {
                let swapType = t.swapType;
                let tokSwapMap = {
                    token: t,
                };
                for (const c2 of allChainIds) {
                    if (c1 === c2)
                        continue;
                    let outToks = SwapPools.tokensForChainBySwapGroup(c2, swapType);
                    if (outToks.length === 0)
                        continue;
                    tokSwapMap[c2] = outToks;
                }
                return tokSwapMap;
            });
        }
        return res;
    }
    TokenSwap.detailedTokenSwapMap = detailedTokenSwapMap;
    async function swapContract(token, chainId) {
        const lpToken = _intermediateToken(token, chainId);
        return BRIDGE_CONFIG_INSTANCE.getPoolConfig(lpToken.address(chainId), chainId)
            .then(({ poolAddress }) => SwapFactory.connect(poolAddress, rpcProviderForChain(chainId)))
            .catch(rejectPromise);
    }
    async function swapSetup(tokenFrom, tokenTo, chainId) {
        const swapInstance = await swapContract(tokenFrom, chainId);
        return Promise.all([
            swapInstance.getTokenIndex(tokenFrom.address(chainId)),
            swapInstance.getTokenIndex(tokenTo.address(chainId)),
        ]).then(([tokenIndexFrom, tokenIndexTo]) => ({
            swapInstance,
            tokenIndexFrom,
            tokenIndexTo,
        })).catch(rejectPromise);
    }
    TokenSwap.swapSetup = swapSetup;
    function _intermediateToken(token, chainId) {
        const { intermediateToken, bridgeConfigIntermediateToken } = intermediateTokens(chainId, token);
        return intermediateToken ?? bridgeConfigIntermediateToken;
    }
    function checkCanSwap(tokenFrom, tokenTo, chainFrom, chainTo) {
        const tokensCanSwap = checkTokensCanSwap(tokenFrom, tokenTo), tokensSupported = checkTokensSupported(tokenFrom, tokenTo, chainFrom, chainTo);
        if (!tokensSupported.swapSupported) {
            return tokensSupported;
        }
        else if (!tokensCanSwap.swapSupported) {
            return tokensCanSwap;
        }
        return { swapSupported: true };
    }
    function checkTokensCanSwap(tokenFrom, tokenTo) {
        let swapSupported = true, reasonNotSupported;
        if (tokenFrom.swapType !== tokenTo.swapType) {
            swapSupported = false;
            reasonNotSupported = UnsupportedSwapErrors.nonMatchingSwapTypes();
        }
        return { swapSupported, reasonNotSupported };
    }
    function checkTokensSupported(tokenFrom, tokenTo, chainIdFrom, chainIdTo) {
        const isSameNet = typeof chainIdTo === "undefined";
        const unsupportedFromErr = isSameNet ? UnsupportedSwapErrors.tokenNotSupported : UnsupportedSwapErrors.tokenNotSupportedNetFrom, unsupportedToErr = isSameNet ? UnsupportedSwapErrors.tokenNotSupported : UnsupportedSwapErrors.tokenNotSupportedNetTo;
        const netFrom = Networks.fromChainId(chainIdFrom), netTo = (typeof chainIdTo !== "undefined" ? Networks.fromChainId(chainIdTo) : netFrom);
        let swapSupported = true, reasonNotSupported;
        if (!netFrom.supportsToken(tokenFrom)) {
            swapSupported = false;
            reasonNotSupported = unsupportedFromErr(tokenFrom, netFrom.name);
        }
        else if (!netTo.supportsToken(tokenTo)) {
            swapSupported = false;
            reasonNotSupported = unsupportedToErr(tokenTo, netTo.name);
        }
        return { swapSupported, reasonNotSupported };
    }
})(TokenSwap || (TokenSwap = {}));
