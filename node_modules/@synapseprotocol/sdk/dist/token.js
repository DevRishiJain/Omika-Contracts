import { BigNumber, } from "@ethersproject/bignumber";
import { parseUnits } from "@ethersproject/units";
export function instanceOfToken(object) {
    return 'name' in object
        && 'isWrappedToken' in object
        && 'valueToWei' in object
        && 'swapType' in object;
}
/**
 * Token represents an ERC20 token on Ethereum-based blockchains.
 */
export class BaseToken {
    id;
    name;
    symbol;
    addresses = {};
    swapType;
    isETH;
    wrapperAddresses = {};
    _decimals = {};
    /**
     * Creates a new Token object with the defined arguments.
     * @param {Object} args Information about this token, including name, symbol, decimals, and
     * contract addresses.
     * @param {string} args.name Name of the token (example, "USD Circle")
     * @param {string} args.symbol Symbol of the token (example, "USDC")
     * @param {number|Object} args.decimals Either a single value, representing the token's ERC20 decimals value on all chains, or
     * a map in the format of { chain id => decimals for chain }.
     * If the latter is passed, values for ALL known chains must be provided.
     * @param {Object} args.addresses Mapping in the format of { chain id => address of token on chain },
     * providing the address of this token on different chains.
     * @param {SwapType} args.swapType Swap type of this token
     */
    constructor(args) {
        this.name = args.name;
        this.symbol = args.symbol;
        this.addresses = args.addresses;
        this.swapType = args.swapType;
        this.wrapperAddresses = args.wrapperAddresses ?? {};
        if (typeof args.decimals === "number") {
            for (const [k,] of Object.entries(this.addresses)) {
                this._decimals[k] = args.decimals;
            }
        }
        else {
            this._decimals = args.decimals;
        }
        this.isETH = args.isETH ?? false;
        this.id = Symbol(this.symbol);
    }
    get isWrappedToken() {
        return false;
    }
    /**
     * Returns the address of this token on a given network, or null if
     * the token does not exist on the passed network.
     * @param {number} chainId Chain ID
     * @return {string|null} Token's contract address for the queried network, or null
     */
    address(chainId) {
        return this.addresses[chainId] || null;
    }
    wrapperAddress(chainId) {
        return this.wrapperAddresses[chainId] || null;
    }
    decimals(chainId) {
        return this._decimals[chainId] || null;
    }
    isEqual(other) {
        return this.id === other.id;
    }
    weiToEther(amt, chainId) {
        const decimals = this.decimals(chainId) || 18, multiplier = BigNumber.from(10).pow(18 - decimals);
        return BigNumber.from(amt).mul(multiplier);
    }
    etherToWei(amt, chainId) {
        let etherStr = amt instanceof BigNumber
            ? amt.toString()
            : BigNumber.from(amt).toString();
        return parseUnits(etherStr, this.decimals(chainId) ?? 18);
    }
    valueToWei(ether, chainId) {
        return this.etherToWei(ether, chainId);
    }
    canSwap(other) {
        return this.swapType === other.swapType;
    }
}
export class WrappedToken extends BaseToken {
    underlyingToken;
    constructor(args) {
        super(args);
        this.underlyingToken = args.underlyingToken;
    }
    get isWrappedToken() {
        return true;
    }
}
