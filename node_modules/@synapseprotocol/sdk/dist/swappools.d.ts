import type { AddressMap, ChainIdTypeMap, DecimalsMap } from "./common/types";
import { BaseToken, type IBaseToken, type Token } from "./token";
import { type ID, SwapType } from "./internal/index";
export declare namespace SwapPools {
    export interface LPToken {
        readonly poolTokens: Token[];
        readonly swapType: SwapType;
    }
    export interface SwapPoolToken extends IBaseToken, LPToken {
        readonly baseToken: BaseToken;
        readonly poolId: number;
        readonly poolName: string;
        readonly poolType: string;
        readonly nativeTokens?: Token[];
        readonly depositTokens?: Token[];
        readonly swapAddress: string;
        readonly swapETHAddress: string | null;
        readonly poolTokensForBridgeSwaps: Token[];
    }
    interface SwapTokenArgs {
        name: string;
        symbol: string;
        decimals: number | DecimalsMap;
        addresses: AddressMap;
        poolId: number;
        poolName: string;
        poolType: SwapType;
        poolTokens: Token[];
        swapAddress: string;
    }
    interface ETHSwapTokenArgs extends SwapTokenArgs {
        nativeTokens?: Token[];
        depositTokens?: Token[];
        swapEthAddress?: string;
    }
    export class SwapToken implements SwapPoolToken {
        readonly baseToken: BaseToken;
        readonly poolId: number;
        readonly poolName: string;
        readonly poolType: SwapType;
        readonly poolTokens: Token[];
        readonly swapAddress: string;
        constructor(args: SwapTokenArgs);
        get id(): ID;
        get name(): string;
        get symbol(): string;
        get addresses(): {
            [k: number]: string;
        };
        get swapType(): SwapType;
        address(chainId: number): string | null;
        decimals(chainId: number): number | null;
        get poolTokensForBridgeSwaps(): Token[];
        get swapETHAddress(): string | null;
    }
    export class ETHSwapToken extends SwapToken {
        readonly nativeTokens: Token[];
        readonly depositTokens: Token[];
        private readonly _swapETHAddress;
        constructor(args: ETHSwapTokenArgs);
        get poolTokensForBridgeSwaps(): Token[];
        get swapETHAddress(): string | null;
    }
    export const ETH_POOL_SWAP_TOKEN: SwapToken;
    export const OPTIMISM_ETH_SWAP_TOKEN: ETHSwapToken;
    export const BSC_POOL_SWAP_TOKEN: SwapToken;
    export const POLYGON_POOL_SWAP_TOKEN: SwapToken;
    export const FANTOM_POOL_SWAP_TOKEN: SwapToken;
    export const FANTOM_ETH_SWAP_TOKEN: ETHSwapToken;
    export const BOBA_POOL_SWAP_TOKEN: SwapToken;
    export const BOBA_ETH_SWAP_TOKEN: ETHSwapToken;
    export const METIS_POOL_SWAP_TOKEN: SwapToken;
    export const METIS_ETH_SWAP_TOKEN: ETHSwapToken;
    export const ARBITRUM_POOL_SWAP_TOKEN: SwapToken;
    export const ARBITRUM_ETH_SWAP_TOKEN: ETHSwapToken;
    export const AVALANCHE_POOL_SWAP_TOKEN: SwapToken;
    export const AVALANCHE_ETH_SWAP_TOKEN: ETHSwapToken;
    export const AURORA_POOL_SWAP_TOKEN: SwapToken;
    export const HARMONY_POOL_SWAP_TOKEN: SwapToken;
    export const HARMONY_ONEETH_TOKEN: ETHSwapToken;
    export interface SwapTypePoolTokens {
        [swapType: string]: LPToken;
    }
    interface BridgeTokenMapping {
        swappableTokens: {
            [swapGroup: string]: Token[];
        };
        swappableSwapGroups: {
            [swapGroup: string]: LPToken;
        };
    }
    interface ChainSwapTypePoolsMap {
        [chainId: number]: BridgeTokenMapping;
    }
    export const bridgeSwappableMap: ChainSwapTypePoolsMap;
    export function swapGroupsForChain(chainId: number): string[];
    export function tokensForChainBySwapGroup(chainId: number, swapGroup: string): Token[];
    export function getAllSwappableTokensForNetwork(chainId: number): Token[];
    export function stableswapPoolForNetwork(chainId: number): SwapPoolToken;
    export function ethSwapPoolForNetwork(chainId: number): SwapPoolToken;
    export {};
}
export declare type NetworkSwappableTokensMap = ChainIdTypeMap<Token[]>;
export declare type AllNetworksSwappableTokensMap = ChainIdTypeMap<NetworkSwappableTokensMap>;
/**
 * Returns a map of swappable tokens for two given networks; or, if a second chainid isn't passed,
 * a map of all swappable tokens for the passed chainid between all supported networks.
 * @param chainIdA
 * @param chainIdB Optional second network; if passed, a map of swappable tokens between ONLY chainIdA and chainIdB is returned.
 * @return NetworkSwappableTokensMap
 */
export declare function networkSwapTokensMap(chainIdA: number, chainIdB?: number): NetworkSwappableTokensMap;
/**
 * Returns map of all swappable tokens between all supported networks.
 * @return AllNetworksSwappableTokensMap
 */
export declare function allNetworksSwapTokensMap(): AllNetworksSwappableTokensMap;
