import { fetchJson } from "@ethersproject/web";
export class RequestError extends Error {
    code;
    data;
    constructor(message, code, data) {
        super(message);
        this.code = code;
        this.data = data;
        this.name = this.constructor.name; // dafuq
        this.message = message; // dafuq message
    }
}
export class MiniRpcProvider {
    isMetaMask = false;
    chainId;
    _url;
    _host;
    _path;
    _batchInterval;
    _nextId = 1;
    _batchAggregator = null;
    _pendingBatch = null;
    constructor(chainId, url, batchWaitTimeMs = 50) {
        this.chainId = chainId;
        const parsed = new URL(url);
        this._url = parsed.toString();
        this._host = parsed.host;
        this._path = parsed.pathname;
        // how long to wait to batch calls
        this._batchInterval = batchWaitTimeMs;
    }
    /**
     * Amount of time, in milliseconds, between batch RPC calls
     */
    get batchInterval() {
        return this._batchInterval;
    }
    /**
     * Sets the provider's interval for sending batch RPC calls.
     * @param interval amount of time in milliseconds the provider will wait between sending batch RPC calls
     * @internal
     */
    set batchInterval(interval) {
        this._batchInterval = interval;
    }
    get url() {
        return this._url;
    }
    /**
     * @internal
     */
    set url(newUrl) {
        const parsed = newUrl instanceof URL ? newUrl : new URL(newUrl);
        this._host = parsed.host;
        this._path = parsed.pathname;
        this._url = parsed.toString();
    }
    get host() {
        return this._host;
    }
    get path() {
        return this._path;
    }
    async request(request) {
        if (request.method === 'eth_chainId') {
            return `0x${this.chainId.toString(16)}`;
        }
        if (this._pendingBatch === null) {
            this._pendingBatch = [];
        }
        const batchItem = {
            request: {
                jsonrpc: "2.0",
                id: (this._nextId++),
                ...request
            },
            resolve: null,
            reject: null,
        };
        const prom = new Promise((resolve, reject) => {
            batchItem.resolve = resolve;
            batchItem.reject = reject;
        });
        this._pendingBatch.push(batchItem);
        if (!this._batchAggregator) {
            setTimeout(() => this._processBatch(), this._batchInterval);
        }
        return prom;
    }
    async _processBatch() {
        let currentBatch = this._pendingBatch;
        this._pendingBatch = null;
        this._batchAggregator = null;
        if (currentBatch === null) {
            currentBatch = [];
        }
        const requests = currentBatch.map(req => req.request);
        if (requests.length === 0) {
            return;
        }
        return fetchJson(this._url, JSON.stringify(requests))
            .then(result => currentBatch.forEach((req, idx) => {
            const payload = result[idx];
            if (payload.error) {
                const { message, code, data } = payload.error;
                req.reject(new RequestError(message, code, data));
            }
            else {
                req.resolve(payload.result);
            }
        }))
            .catch(error => currentBatch.forEach(batchItem => batchItem.reject(error)));
    }
}
